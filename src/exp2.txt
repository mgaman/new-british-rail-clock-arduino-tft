/*
   To force 1 cycle to take 30 secs
   need to advance 1 pixel every 30000/240 msec i.e. 125 msec
   Add a text sprite do dispay current second within cycle
*/

#include <Arduino.h>
#include <SPI.h>
#include <TFT_eSPI.h> // Hardware-specific library


#define TFT_GREY 0x5AEB

#define BASE_COLOR TFT_PURPLE

#define LINE_HEIGHT 10
#define LINE_COLOR TFT_YELLOW

#define DOT_RADIUS 20
#define DOT_COLOR TFT_CYAN

#define BASE_BORDER 1   // gap around base sprite and screen

TFT_eSPI tft = TFT_eSPI()  ;    // Invoke custom library
TFT_eSprite baseSprite = TFT_eSprite(&tft);
TFT_eSprite lineSprite = TFT_eSprite(&tft);
TFT_eSprite dotSprite = TFT_eSprite(&tft);
TFT_eSprite textSprite = TFT_eSprite(&tft);
hw_timer_t *Timer0_Cfg = NULL;
 

#define BLPIN 22
unsigned int sWidth,sHeight,dotYpos,dotXpos,lineXpos,lineYpos,currentCycle;
bool dotLR,timerTicked = false;

void IRAM_ATTR Timer0_ISR()
{
    timerTicked = true;
}

void setup(void) {
  Serial.begin(115200);
  sWidth = tft.width();
  sHeight = tft.height();
  pinMode(BLPIN,OUTPUT);
  digitalWrite(BLPIN,HIGH);
  tft.init();
  tft.setRotation(0);
  tft.fillScreen(BASE_COLOR); 
  // create base sprite & fill it
  baseSprite.createSprite(sWidth-(BASE_BORDER*2),sHeight-(BASE_BORDER*2));  // cannot have sprite exact same size as screen
  baseSprite.fillSprite(BASE_COLOR);
  // create line sprite & locate in center of base sprite
  lineSprite.createSprite(sWidth-(BASE_BORDER*2),LINE_HEIGHT);
  lineSprite.fillRect(0,0,lineSprite.width(),lineSprite.height(),LINE_COLOR);
  lineXpos = 0;
  lineYpos =  (baseSprite.height()-LINE_HEIGHT)/2;   // relative to base
  // draw dot across center of base sprite
  dotSprite.createSprite(DOT_RADIUS*2,DOT_RADIUS*2);
  dotSprite.fillSprite(TFT_BLACK);
  dotSprite.fillCircle(DOT_RADIUS,DOT_RADIUS,DOT_RADIUS,DOT_COLOR);
  dotXpos = 0;
  dotYpos = baseSprite.height()/2 - DOT_RADIUS;
  // create text sprite
  textSprite.createSprite(80,80);
  textSprite.setTextColor(TFT_WHITE,TFT_BLACK);
  Timer0_Cfg = timerBegin(0, 80, true);
  timerAttachInterrupt(Timer0_Cfg, &Timer0_ISR, true);
  timerAlarmWrite(Timer0_Cfg, 125000, true);
  timerAlarmEnable(Timer0_Cfg);
}


void drawScreen() {
  // repair base sprite
  baseSprite.fillSprite(BASE_COLOR);
  // draw line to base
  lineSprite.pushToSprite(&baseSprite,lineXpos,lineYpos);
  // draw dot to base
  Serial.printf("x %d y %d\r\n",dotXpos,dotYpos);
  dotSprite.pushToSprite(&baseSprite,dotXpos++,dotYpos,TFT_BLACK);  // ignore background color
  if (dotXpos == baseSprite.width()) {
    dotXpos = 0;
    currentCycle = 0;
    }
  // update text & push to base
    textSprite.fillSprite(TFT_BLACK);
    textSprite.drawString(String(currentCycle++/8),0,0,6);  // 8 pixels per sec
    textSprite.pushToSprite(&baseSprite,100,10,TFT_BLACK);
  // push base to screen
  baseSprite.pushSprite(BASE_BORDER,BASE_BORDER);  // do not ignore background color
}
void loop() {
    if (timerTicked) {
        drawScreen();
        timerTicked = false;
    }
}


