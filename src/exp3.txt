/*
   To force 1 cycle to take 30 secs
   need to advance 1 pixel every 30000000/240 microsec i.e. 125 msec
   Add a text sprite do display current second within cycle

   Location of dot for triangle where hypotenuse = (CIRCLE_INNER_RADIUS+CIRCLE_OUTER_RADIUS)/2 and angle = A
   cos(A) = x/hypotenuse
   x = hypotenuse*cos(A);
   y = hypotenuse*sin(A);
*/

#include <Arduino.h>
#include <math.h>
#include <SPI.h>
#include <TFT_eSPI.h> // Hardware-specific library

//#define TFT_GREY 0x5AEB

#define BASE_COLOR TFT_BLACK

#define CIRCLE_COLOR TFT_WHITE
#define CIRCLE_THICKNESS 4

#define DOT_RADIUS 10
#define DOT_COLOR TFT_WHITE

#define BASE_BORDER 10   // gap around base sprite and screen so base is 232x232
#define ARROW_HEIGHT 4
#define DOT_STEPS 480  // steps per 360 degrees

TFT_eSPI tft = TFT_eSPI()  ;    // Invoke custom library
TFT_eSprite baseSprite = TFT_eSprite(&tft);  // contains circles
TFT_eSprite dotSprite = TFT_eSprite(&tft);  // contains circles
hw_timer_t *Timer0_Cfg = NULL;
 

#define BLPIN 22
unsigned int sWidth,sHeight,dotYpos,dotXpos,lineXpos,lineYpos,currentCycle;
bool dotLR,timerTicked = false;
unsigned int CIRCLE_INNER_RADIUS,CIRCLE_OUTER_RADIUS,CURRENT_STEP;
float hypotenuse;

void IRAM_ATTR Timer0_ISR()
{
    timerTicked = true;
}

void drawDotSprite() {
  dotSprite.fillSprite(TFT_BLACK);
  dotSprite.fillCircle(DOT_RADIUS,DOT_RADIUS,DOT_RADIUS,DOT_COLOR);
}

void drawBase() {
  baseSprite.fillSprite(BASE_COLOR);
  baseSprite.drawString("Hello",100,40);
  baseSprite.drawArc(baseSprite.width()/2,baseSprite.height()/2,CIRCLE_OUTER_RADIUS,CIRCLE_INNER_RADIUS,0,360,CIRCLE_COLOR,BASE_COLOR,true);
  baseSprite.pushSprite(BASE_BORDER,BASE_BORDER,BASE_COLOR);
}

void setup(void) {
  Serial.begin(115200);
  sWidth = tft.width();
  // calculate some values
  sHeight = tft.height();
  pinMode(BLPIN,OUTPUT);
  digitalWrite(BLPIN,HIGH);
  tft.init();
  tft.setRotation(0);
  tft.fillScreen(BASE_COLOR); 
  // create base sprite & fill it
  baseSprite.createSprite(sWidth-(BASE_BORDER*2),sHeight-(BASE_BORDER*2));  // cannot have sprite exact same size as screen
  CIRCLE_OUTER_RADIUS = (baseSprite.width()/2) - ARROW_HEIGHT;
  CIRCLE_INNER_RADIUS = CIRCLE_OUTER_RADIUS - CIRCLE_THICKNESS;
  hypotenuse = (CIRCLE_INNER_RADIUS+CIRCLE_OUTER_RADIUS)/2.0f;
  Serial.printf("OR %d IR %d hyp %f\r\n",CIRCLE_INNER_RADIUS,CIRCLE_OUTER_RADIUS,hypotenuse);
  drawBase();
  // push base to screen
  baseSprite.pushSprite(BASE_BORDER,BASE_BORDER);  // do not ignore background color
 
  // create a dot sprite and draw dot on the circle
  dotSprite.createSprite(DOT_RADIUS*2,DOT_RADIUS*2);
  drawDotSprite();

  CURRENT_STEP = 0;
  // set timer to interrupt DOT_STEPS times every 60 secs
  Timer0_Cfg = timerBegin(0, 80, true);
  timerAttachInterrupt(Timer0_Cfg, &Timer0_ISR, true);
  timerAlarmWrite(Timer0_Cfg, 60000000L/DOT_STEPS, true);
  timerAlarmEnable(Timer0_Cfg);
}


void drawScreen() {
  drawBase();
  // draw dot
  drawDotSprite();
  // place at correct angle
  float currentAngle = (2.0F*PI*CURRENT_STEP)/float(DOT_STEPS);  // angle in radians
  float x = hypotenuse*sin(currentAngle);
  float y = hypotenuse*cos(currentAngle);
  //Serial.printf("x %f y %f CS %d ca %f\r\n",x,y,CURRENT_STEP,currentAngle);
  dotSprite.pushToSprite(&baseSprite,(baseSprite.width()/2)+int32_t(x)-DOT_RADIUS,(baseSprite.width()/2)-int32_t(y)-DOT_RADIUS,TFT_BLACK);
  if (++CURRENT_STEP == DOT_STEPS)
    CURRENT_STEP = 0;

  // push base to screen
  baseSprite.pushSprite(BASE_BORDER,BASE_BORDER);  // do not ignore background color
}
void loop() {
    if (timerTicked) {
        drawScreen();
        timerTicked = false;
    }
}


